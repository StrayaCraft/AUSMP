From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <spottedleaf@spottedleaf.dev>
Date: Fri, 6 Nov 2020 02:51:39 -0800
Subject: [PATCH] fixup! Highly optimise single and multi-AABB VoxelShapes and
 collisions


diff --git a/src/main/java/com/tuinity/tuinity/voxel/AABBVoxelShape.java b/src/main/java/com/tuinity/tuinity/voxel/AABBVoxelShape.java
index b321ad51635949d07b9b818f2940a31bca1a74e3..002abb3cbf0f742e685f2f043d2600de03e37a19 100644
--- a/src/main/java/com/tuinity/tuinity/voxel/AABBVoxelShape.java
+++ b/src/main/java/com/tuinity/tuinity/voxel/AABBVoxelShape.java
@@ -143,6 +143,9 @@ public final class AABBVoxelShape extends VoxelShape {
 
     @Override
     public double a(EnumDirection.EnumAxis enumdirection_enumaxis, AxisAlignedBB axisalignedbb, double d0) { // collide
+        if (this.aabb.isEmpty() || axisalignedbb.isEmpty()) {
+            return d0;
+        }
         switch (enumdirection_enumaxis.ordinal()) {
             case 0:
                 return AxisAlignedBB.collideX(this.aabb, axisalignedbb, d0);
diff --git a/src/main/java/net/minecraft/server/AxisAlignedBB.java b/src/main/java/net/minecraft/server/AxisAlignedBB.java
index 6aa9f07336c23150ca72bdf3d45677e8d40ee4e9..d759a6c2b347d6f26f0f122cdd6b718c188633c5 100644
--- a/src/main/java/net/minecraft/server/AxisAlignedBB.java
+++ b/src/main/java/net/minecraft/server/AxisAlignedBB.java
@@ -45,9 +45,6 @@ public class AxisAlignedBB {
     }
 
     public static double collideX(AxisAlignedBB target, AxisAlignedBB source, double source_move) {
-        if (target.isEmpty() || source.isEmpty()) {
-            return source_move;
-        }
         if (Math.abs(source_move) < MCUtil.COLLISION_EPSILON) {
             return 0.0;
         }
@@ -73,9 +70,6 @@ public class AxisAlignedBB {
     }
 
     public static double collideY(AxisAlignedBB target, AxisAlignedBB source, double source_move) {
-        if (target.isEmpty() || source.isEmpty()) {
-            return source_move;
-        }
         if (Math.abs(source_move) < MCUtil.COLLISION_EPSILON) {
             return 0.0;
         }
@@ -100,9 +94,6 @@ public class AxisAlignedBB {
     }
 
     public static double collideZ(AxisAlignedBB target, AxisAlignedBB source, double source_move) {
-        if (target.isEmpty() || source.isEmpty()) {
-            return source_move;
-        }
         if (Math.abs(source_move) < MCUtil.COLLISION_EPSILON) {
             return 0.0;
         }
diff --git a/src/main/java/net/minecraft/server/BlockBase.java b/src/main/java/net/minecraft/server/BlockBase.java
index 829d4a7508e1656dbdc912096b7eafcf30cbb5b2..4d1ac4e6b61897fc03b091475ef7be3ed0b228a9 100644
--- a/src/main/java/net/minecraft/server/BlockBase.java
+++ b/src/main/java/net/minecraft/server/BlockBase.java
@@ -366,6 +366,17 @@ public abstract class BlockBase {
         }
         // Tuinity end
 
+        // Tuinity start
+        public static boolean isSpecialCollidingBlock(BlockBase.BlockData blockData) {
+            return blockData.shapeExceedsCube() || blockData.getBlock() == Blocks.MOVING_PISTON;
+        }
+
+        protected long blockCollisionBehavior = ChunkSection.KNOWN_SPECIAL_BLOCK;
+        public final long getBlockCollisionBehavior() {
+            return this.blockCollisionBehavior;
+        }
+        // Tuinity end
+
         public void a() {
             this.fluid = this.getBlock().d(this.p()); // Paper - moved from getFluid()
             this.isTicking = this.getBlock().isTicking(this.p()); // Paper - moved from isTicking()
@@ -402,6 +413,33 @@ public abstract class BlockBase {
                 }
             }
             // Tuinity end - optimise culling shape cache for light
+            // Tuinity start - init block collision behavior field
+            if (isSpecialCollidingBlock(this)) {
+                this.blockCollisionBehavior = ChunkSection.KNOWN_SPECIAL_BLOCK;
+            } else {
+                try {
+                    VoxelShape constantShape = this.getCollisionShape(null, null, null);
+                    if (constantShape == null) {
+                        this.blockCollisionBehavior = ChunkSection.KNOWN_UNKNOWN_BLOCK;
+                    } else {
+                        if (constantShape.isEmpty()) {
+                            this.blockCollisionBehavior = ChunkSection.KNOWN_EMPTY_BLOCK;
+                        } else {
+                            List<AxisAlignedBB> boxes = constantShape.simplify().getBoundingBoxesRepresentation();
+                            if (boxes.size() == 1 && boxes.get(0).equals(VoxelShapes.optimisedFullCube.aabb)) {
+                                this.blockCollisionBehavior = ChunkSection.KNOWN_FULL_BLOCK;
+                            } else {
+                                this.blockCollisionBehavior = ChunkSection.KNOWN_UNKNOWN_BLOCK;
+                            }
+                        }
+                    }
+                } catch (ThreadDeath thr) {
+                    throw thr;
+                } catch (Throwable thr) {
+                    this.blockCollisionBehavior = ChunkSection.KNOWN_UNKNOWN_BLOCK;
+                }
+            }
+            // Tuinity end - init block collision behavior field
 
         }
 
diff --git a/src/main/java/net/minecraft/server/ChunkCache.java b/src/main/java/net/minecraft/server/ChunkCache.java
index 53c977513d3c243e6d06f252ed417c5d6db4034e..ab8664ef2793fde0b3d7836281b4410648db83f0 100644
--- a/src/main/java/net/minecraft/server/ChunkCache.java
+++ b/src/main/java/net/minecraft/server/ChunkCache.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import java.util.List;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
@@ -15,23 +16,33 @@ public class ChunkCache implements IBlockAccess, ICollisionAccess {
     // Tuinity start - optimise pathfinder collision detection
     @Override
     public boolean getCubes(Entity entity) {
-        return !this.collidesWithAnyBlockOrWorldBorder(entity, entity.getBoundingBox());
+        return !this.getCollisionsForBlocksOrWorldBorder(entity, entity.getBoundingBox(), null, true, null);
     }
 
     @Override
     public boolean getCubes(Entity entity, AxisAlignedBB axisalignedbb) {
-        return !this.collidesWithAnyBlockOrWorldBorder(entity, axisalignedbb);
+        return !this.getCollisionsForBlocksOrWorldBorder(entity, axisalignedbb, null, true, null);
     }
 
     @Override
     public boolean getCubes(@Nullable Entity entity, AxisAlignedBB axisalignedbb, Predicate<Entity> predicate) {
-        return !this.collidesWithAnyBlockOrWorldBorder(entity, axisalignedbb);
+        return !this.getCollisionsForBlocksOrWorldBorder(entity, axisalignedbb, null, true, null);
     }
 
-    public boolean collidesWithAnyBlockOrWorldBorder(@Nullable Entity entity, AxisAlignedBB axisalignedbb) {
+    public boolean getCollisionsForBlocksOrWorldBorder(@Nullable Entity entity, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list,
+                                                    boolean collidesWithUnloaded,
+                                                    java.util.function.BiPredicate<IBlockData, BlockPosition> predicate) {
+        boolean ret = false;
+        final boolean checkOnly = true;
+
         if (entity != null) {
             if (this.getWorldBorder().isCollidingOnBorderEdge(axisalignedbb)) {
-                return true;
+                if (checkOnly) {
+                    return true;
+                } else {
+                    VoxelShapes.addBoxesTo(this.getWorldBorder().getCollisionShape(), list);
+                    ret = true;
+                }
             }
         }
 
@@ -46,12 +57,12 @@ public class ChunkCache implements IBlockAccess, ICollisionAccess {
 
 
         BlockPosition.MutableBlockPosition mutablePos = new BlockPosition.MutableBlockPosition();
-        VoxelShapeCollision collisionShape = entity == null ? VoxelShapeCollision.a() : VoxelShapeCollision.a(entity); // TODO make this lazy
+        VoxelShapeCollision collisionShape = null;
 
         // special cases:
         if (minBlockY > 255 || maxBlockY < 0) {
             // no point in checking
-            return false;
+            return ret;
         }
 
         int minYIterate = Math.max(0, minBlockY);
@@ -78,7 +89,15 @@ public class ChunkCache implements IBlockAccess, ICollisionAccess {
                 Chunk chunk = (Chunk)this.getChunkIfLoaded(currChunkX, currChunkZ);
 
                 if (chunk == null) {
-                    return true;
+                    if (collidesWithUnloaded) {
+                        if (checkOnly) {
+                            return true;
+                        } else {
+                            list.add(AxisAlignedBB.getBoxForChunk(currChunkX, currChunkZ));
+                            ret = true;
+                        }
+                    }
+                    continue;
                 }
 
                 ChunkSection[] sections = chunk.getSections();
@@ -94,47 +113,103 @@ public class ChunkCache implements IBlockAccess, ICollisionAccess {
                         continue;
                     }
 
-                    DataPaletteBlock<IBlockData> blocks = section.blockIds;
-                    int blockKeyY = (currY & 15) << 8;
-
-                    int edgeCountY = (currY == minBlockY || currY == maxBlockY) ? 1 : 0;
-
-                    for (int currZ = minZ; currZ <= maxZ; ++currZ) {
-                        int blockKeyZY = blockKeyY | (currZ << 4);
-                        int blockZ = currZ | chunkZGlobalPos; // world position
-
-                        int edgeCountZY;
-                        if (blockZ == minBlockZ || blockZ == maxBlockZ) {
-                            edgeCountZY = edgeCountY + 1;
-                        } else {
-                            edgeCountZY = edgeCountY;
-                        }
+                    int minXIterate;
+                    int maxXIterate;
+                    int minZIterate;
+                    int maxZIterate;
 
-                        for (int currX = minX; currX <= maxX; ++currX) {
-                            int blockX = currX | chunkXGlobalPos; // world position
-
-                            int edgeCountFull;
-                            if (blockX == minBlockX || blockX == maxBlockX) {
-                                edgeCountFull = edgeCountZY + 1;
-                            } else {
-                                edgeCountFull = edgeCountZY;
-                            }
+                    boolean sectionHasSpecial = section.hasSpecialCollidingBlocks();
+                    if (sectionHasSpecial && currChunkX == minChunkX) {
+                        minXIterate = minX + 1;
+                    } else {
+                        minXIterate = minX;
+                    }
+                    if (sectionHasSpecial && currChunkX == maxChunkX) {
+                        maxXIterate = maxX - 1;
+                    } else {
+                        maxXIterate = maxX;
+                    }
 
-                            if (edgeCountFull == 3) {
-                                continue;
-                            }
+                    if (sectionHasSpecial && currChunkZ == minChunkZ) {
+                        minZIterate = minZ + 1;
+                    } else {
+                        minZIterate = minZ;
+                    }
+                    if (sectionHasSpecial && currChunkZ == maxChunkZ) {
+                        maxZIterate = maxZ - 1;
+                    } else {
+                        maxZIterate = maxZ;
+                    }
 
-                            int blockKeyFull = blockKeyZY | currX;
-                            IBlockData blockData = blocks.rawGet(blockKeyFull);
+                    DataPaletteBlock<IBlockData> blocks = section.blockIds;
 
-                            if (!blockData.isAir() && (edgeCountFull != 1 || blockData.shapeExceedsCube()) && (edgeCountFull != 2 || blockData.getBlock() == Blocks.MOVING_PISTON)) {
-                                mutablePos.setValues(blockX, currY, blockZ);
-                                VoxelShape voxelshape2 = blockData.getCollisionShape(this, mutablePos, collisionShape);
-                                if (voxelshape2 != VoxelShapes.getEmptyShape()) {
-                                    VoxelShape voxelshape3 = voxelshape2.offset((double)blockX, (double)currY, (double)blockZ);
+                    for (int currZ = minZIterate; currZ <= maxZIterate; ++currZ) {
+                        block_search_loop:
+                        for (int currX = minXIterate; currX <= maxXIterate; ++currX) {
+                            int localBlockIndex = (currX) | (currZ << 4) | ((currY & 15) << 8);
+                            long blockInfo = section.getKnownBlockInfo(localBlockIndex);
+                            switch ((int)blockInfo) {
+                                case (int)ChunkSection.KNOWN_EMPTY_BLOCK: {
+                                    continue block_search_loop;
+                                }
+                                case (int)ChunkSection.KNOWN_FULL_BLOCK: {
+                                    AxisAlignedBB box = new AxisAlignedBB(
+                                            currX | chunkXGlobalPos, currY, currZ | chunkZGlobalPos,
+                                            (currX | chunkXGlobalPos) + 1, currY + 1, (currZ | chunkZGlobalPos) + 1,
+                                            false
+                                    );
+                                    if (predicate != null) {
+                                        if (!box.voxelShapeIntersect(axisalignedbb)) {
+                                            continue block_search_loop;
+                                        }
+                                        // fall through to get the block for the predicate
+                                    } else {
+                                        if (box.voxelShapeIntersect(axisalignedbb)) {
+                                            if (checkOnly) {
+                                                return true;
+                                            } else {
+                                                list.add(box);
+                                                ret = true;
+                                            }
+                                        }
+                                        continue block_search_loop;
+                                    }
+                                }
+                                default: {
+                                    int blockX = currX | chunkXGlobalPos;
+                                    int blockY = currY;
+                                    int blockZ = currZ | chunkZGlobalPos;
+
+                                    int edgeCount = ((blockX == minBlockX || blockX == maxBlockX) ? 1 : 0) +
+                                            ((blockY == minBlockY || blockY == maxBlockY) ? 1 : 0) +
+                                            ((blockZ == minBlockZ || blockZ == maxBlockZ) ? 1 : 0);
+                                    if (edgeCount == 3 || (edgeCount != 0 && blockInfo != ChunkSection.KNOWN_SPECIAL_BLOCK)) {
+                                        continue block_search_loop;
+                                    }
 
-                                    if (voxelshape3.intersects(axisalignedbb)) {
-                                        return true;
+                                    IBlockData blockData = blocks.rawGet(localBlockIndex);
+
+                                    if ((edgeCount != 1 || blockData.shapeExceedsCube()) && (edgeCount != 2 || blockData.getBlock() == Blocks.MOVING_PISTON)) {
+                                        if (collisionShape == null) {
+                                            collisionShape = entity == null ? VoxelShapeCollision.a() : VoxelShapeCollision.a(entity);
+                                        }
+                                        mutablePos.setValues(blockX, blockY, blockZ);
+                                        VoxelShape voxelshape2 = blockData.getCollisionShape(this, mutablePos, collisionShape);
+                                        if (voxelshape2 != VoxelShapes.getEmptyShape()) {
+                                            VoxelShape voxelshape3 = voxelshape2.offset((double)blockX, (double)blockY, (double)blockZ);
+
+                                            if (predicate != null && !predicate.test(blockData, mutablePos)) {
+                                                continue block_search_loop;
+                                            }
+
+                                            if (checkOnly) {
+                                                if (voxelshape3.intersects(axisalignedbb)) {
+                                                    return true;
+                                                }
+                                            } else {
+                                                ret |= VoxelShapes.addBoxesToIfIntersects(voxelshape3, axisalignedbb, list);
+                                            }
+                                        }
                                     }
                                 }
                             }
@@ -144,7 +219,7 @@ public class ChunkCache implements IBlockAccess, ICollisionAccess {
             }
         }
 
-        return false;
+        return ret;
     }
     // Tuinity end - optimise pathfinder collision detection
 
diff --git a/src/main/java/net/minecraft/server/ChunkSection.java b/src/main/java/net/minecraft/server/ChunkSection.java
index 33b8f4e0f09fdc41c8ea48b6ed77af199136ab92..ea943e44abb0ea9f7d471070fee14f6e5f205d53 100644
--- a/src/main/java/net/minecraft/server/ChunkSection.java
+++ b/src/main/java/net/minecraft/server/ChunkSection.java
@@ -15,6 +15,41 @@ public class ChunkSection {
 
     final com.destroystokyo.paper.util.maplist.IBlockDataList tickingList = new com.destroystokyo.paper.util.maplist.IBlockDataList(); // Paper
 
+    // Tuinity start
+    protected int specialCollidingBlocks;
+
+    public final boolean hasSpecialCollidingBlocks() {
+        return this.specialCollidingBlocks != 0;
+    }
+
+    private final long[] knownBlockCollisionData = new long[16 * 16 * 16 * 2 / 64]; // blocks * bits per block / bits per long
+    public static final long KNOWN_EMPTY_BLOCK = 0b00; // known to have voxelshape of empty
+    public static final long KNOWN_FULL_BLOCK = 0b01; // known to have voxelshape of full cube
+    public static final long KNOWN_UNKNOWN_BLOCK = 0b10; // must read the actual block state for info
+    public static final long KNOWN_SPECIAL_BLOCK = 0b11; // caller must check this block for special collisions
+
+    private final void updateKnownBlockInfo(int blockIndex, IBlockData blockData) {
+        int arrayIndex = (blockIndex >>> (6 - 1)); // blockIndex / (64/2)
+        int valueShift = (blockIndex & (Long.SIZE / 2 - 1));
+
+        long value = this.knownBlockCollisionData[arrayIndex];
+
+        value &= ~(0b11L << (valueShift << 1));
+        value |= (blockData.getBlockCollisionBehavior() << (valueShift << 1));
+
+        this.knownBlockCollisionData[arrayIndex] = value;
+    }
+
+    public final long getKnownBlockInfo(int blockIndex) {
+        int arrayIndex = (blockIndex >>> (6 - 1)); // blockIndex / (64/2)
+        int valueShift = (blockIndex & (Long.SIZE / 2 - 1));
+
+        long value = this.knownBlockCollisionData[arrayIndex];
+
+        return (value >>> (valueShift << 1)) & 0b11L;
+    }
+    // Tuinity end
+
     // Paper start - Anti-Xray - Add parameters
     @Deprecated public ChunkSection(int i) { this(i, null, null, true); } // Notice for updates: Please make sure this constructor isn't used anywhere
     public ChunkSection(int i, IChunkAccess chunk, World world, boolean initializeBlocks) {
@@ -62,6 +97,16 @@ public class ChunkSection {
             iblockdata1 = (IBlockData) this.blockIds.b(i, j, k, iblockdata);
         }
 
+        // Tuinity start
+        this.updateKnownBlockInfo(i | (k << 4) | (j << 8), iblockdata);
+        if (iblockdata1.getBlockCollisionBehavior() == KNOWN_SPECIAL_BLOCK) {
+            --this.specialCollidingBlocks;
+        }
+        if (iblockdata.getBlockCollisionBehavior() == KNOWN_SPECIAL_BLOCK) {
+            ++this.specialCollidingBlocks;
+        }
+        // Tuinity end
+
         Fluid fluid = iblockdata1.getFluid();
         Fluid fluid1 = iblockdata.getFluid();
 
@@ -130,6 +175,12 @@ public class ChunkSection {
         this.tickingBlockCount = 0;
         this.e = 0;
         this.blockIds.forEachLocation((iblockdata, location) -> { // Paper
+            // Tuinity start
+            if (iblockdata.getBlockCollisionBehavior() == KNOWN_SPECIAL_BLOCK) {
+                ++this.specialCollidingBlocks;
+            }
+            this.updateKnownBlockInfo(location, iblockdata);
+            // Tuinity end
             Fluid fluid = iblockdata.getFluid();
 
             if (!iblockdata.isAir()) {
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index 420557c27029e2464e3c02143a1724a9bf165268..152f3cc5b0a8dfd6207b8fa59716132964cc8f52 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -785,7 +785,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
             }
 
             try {
-                this.checkBlockCollisions();
+                this.checkBlockCollisions(this.fireTicks <= 0); // Tuinity - move fire checking into method here
             } catch (Throwable throwable) {
                 CrashReport crashreport = CrashReport.a(throwable, "Checking entity block collision");
                 CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being checked for collision");
@@ -797,39 +797,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
             float f2 = this.getBlockSpeedFactor();
 
             this.setMot(this.getMot().d((double) f2, 1.0D, (double) f2));
-            // Tuinity start - remove streams here
-            if (this.fireTicks <= 0) {
-                AxisAlignedBB boundingBox = this.getBoundingBox().shrink(0.001D);
-                BlockPosition.MutableBlockPosition mutablePos = new BlockPosition.MutableBlockPosition();
-                int minX = MathHelper.floor(boundingBox.minX);
-                int minY = MathHelper.floor(boundingBox.minY);
-                int minZ = MathHelper.floor(boundingBox.minZ);
-                int maxX = MathHelper.floor(boundingBox.maxX);
-                int maxY = MathHelper.floor(boundingBox.maxY);
-                int maxZ = MathHelper.floor(boundingBox.maxZ);
-                boolean inFireLoaded = true;
-                boolean inFire = false;
-                fire_search:
-                for (int currY = minY; currY <= maxY; ++currY) {
-                    for (int currZ = minZ; currZ <= maxZ; ++currZ) {
-                        for (int currX = minX; currX <= maxX; ++currX) {
-                            mutablePos.setValues(currX, currY, currZ);
-                            IBlockData type = this.getWorld().getTypeIfLoaded(mutablePos);
-                            if (type == null) {
-                                inFireLoaded = false;
-                                break fire_search;
-                            }
-                            if (!inFire && (type.a(TagsBlock.FIRE) || type.a(Blocks.LAVA))) {
-                                inFire = true;
-                            }
-                        }
-                    }
-                }
-                if (!inFire & inFireLoaded) {
-                    this.setFireTicks(-this.getMaxFireTicks());
-                }
-            }
-            // Tuinity end - remove streams here
+            // Tuinity - move into checkBlockCollisions
 
             if (this.aG() && this.isBurning()) {
                 this.playSound(SoundEffects.ENTITY_GENERIC_EXTINGUISH_FIRE, 0.7F, 1.6F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
@@ -1199,18 +1167,34 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
     }
 
     protected void checkBlockCollisions() {
+        // Tuinity start
+        this.checkBlockCollisions(false);
+    }
+    protected void checkBlockCollisions(boolean checkFire) {
+        boolean inFire = false;
+        // Tuinity end
         AxisAlignedBB axisalignedbb = this.getBoundingBox();
         BlockPosition blockposition = new BlockPosition(axisalignedbb.minX + 0.001D, axisalignedbb.minY + 0.001D, axisalignedbb.minZ + 0.001D);
         BlockPosition blockposition1 = new BlockPosition(axisalignedbb.maxX - 0.001D, axisalignedbb.maxY - 0.001D, axisalignedbb.maxZ - 0.001D);
         BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
 
         if (this.world.areChunksLoadedBetween(blockposition, blockposition1)) {
-            for (int i = blockposition.getX(); i <= blockposition1.getX(); ++i) {
-                for (int j = blockposition.getY(); j <= blockposition1.getY(); ++j) {
-                    for (int k = blockposition.getZ(); k <= blockposition1.getZ(); ++k) {
+            // Tuinity start - reorder iteration to more cache aware
+            for (int j = blockposition.getY(); j <= blockposition1.getY(); ++j) {
+                for (int k = blockposition.getZ(); k <= blockposition1.getZ(); ++k) {
+                    for (int i = blockposition.getX(); i <= blockposition1.getX(); ++i) {
+                        // Tuinity end - reorder iteration to more cache aware
                         blockposition_mutableblockposition.d(i, j, k);
                         IBlockData iblockdata = this.world.getType(blockposition_mutableblockposition);
 
+                        // Tuinity start - move fire checking in here - reuse getType from this method
+                        if (checkFire) {
+                            if (!inFire && (iblockdata.a(TagsBlock.FIRE) || iblockdata.a(Blocks.LAVA))) {
+                                inFire = true;
+                            }
+                        }
+                        // Tuinity end - move fire checking in here - reuse getType from this method
+
                         try {
                             iblockdata.a(this.world, blockposition_mutableblockposition, this);
                             this.a(iblockdata);
@@ -1224,6 +1208,11 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
                     }
                 }
             }
+            // Tuinity start - move fire checking in here - reuse getType from this method
+            if (checkFire & !inFire) {
+                this.setFireTicks(-this.getMaxFireTicks());
+            }
+            // Tuinity end - move fire checking in here - reuse getType from this method
         }
 
     }
diff --git a/src/main/java/net/minecraft/server/ICollisionAccess.java b/src/main/java/net/minecraft/server/ICollisionAccess.java
index b66c802d5e27518069bf42e577bcc9a26c4d873e..cce0ac8a36bef3b9e5a2b95e0c3dd137e8525226 100644
--- a/src/main/java/net/minecraft/server/ICollisionAccess.java
+++ b/src/main/java/net/minecraft/server/ICollisionAccess.java
@@ -28,6 +28,11 @@ public interface ICollisionAccess extends IBlockAccess {
     }
 
     default boolean b(AxisAlignedBB axisalignedbb) {
+        // Tuinity start - allow overriding in WorldServer
+        return this.getCubes(axisalignedbb);
+    }
+    default boolean getCubes(AxisAlignedBB axisalignedbb) {
+        // Tuinity end - allow overriding in WorldServer
         return this.b((Entity) null, axisalignedbb, (entity) -> {
             return true;
         });
diff --git a/src/main/java/net/minecraft/server/VoxelShapes.java b/src/main/java/net/minecraft/server/VoxelShapes.java
index db735e29d427cc8f4bd4ba54c7a44daf9fed9e61..636bbbc42466cb54c300352f400464fe64cc2e79 100644
--- a/src/main/java/net/minecraft/server/VoxelShapes.java
+++ b/src/main/java/net/minecraft/server/VoxelShapes.java
@@ -36,12 +36,14 @@ public final class VoxelShapes {
     static final com.tuinity.tuinity.voxel.AABBVoxelShape optimisedFullCube = new com.tuinity.tuinity.voxel.AABBVoxelShape(new AxisAlignedBB(0, 0, 0, 1.0, 1.0, 1.0)); // Tuinity - optimise voxelshape
 
     // Tuinity start - optimise voxelshapes
-    public static void addBoxesToIfIntersects(VoxelShape shape, AxisAlignedBB aabb, java.util.List<AxisAlignedBB> list) {
+    public static boolean addBoxesToIfIntersects(VoxelShape shape, AxisAlignedBB aabb, java.util.List<AxisAlignedBB> list) {
         if (shape instanceof com.tuinity.tuinity.voxel.AABBVoxelShape) {
             com.tuinity.tuinity.voxel.AABBVoxelShape shapeCasted = (com.tuinity.tuinity.voxel.AABBVoxelShape)shape;
-            if (shapeCasted.aabb.voxelShapeIntersect(aabb)) {
+            if (!shapeCasted.aabb.isEmpty() && shapeCasted.aabb.voxelShapeIntersect(aabb)) {
                 list.add(shapeCasted.aabb);
+                return true;
             }
+            return false;
         } else if (shape instanceof VoxelShapeArray) {
             VoxelShapeArray shapeCasted = (VoxelShapeArray)shape;
             // this can be optimised by checking an "overall shape" first, but not needed
@@ -50,39 +52,58 @@ public final class VoxelShapes {
             double offY = shapeCasted.offsetY;
             double offZ = shapeCasted.offsetZ;
 
+            boolean ret = false;
+
             for (AxisAlignedBB boundingBox : shapeCasted.boundingBoxesRepresentation) {
                 double minX, minY, minZ, maxX, maxY, maxZ;
                 if (aabb.voxelShapeIntersect(minX = boundingBox.minX + offX, minY = boundingBox.minY + offY, minZ = boundingBox.minZ + offZ,
                         maxX = boundingBox.maxX + offX, maxY = boundingBox.maxY + offY, maxZ = boundingBox.maxZ + offZ)) {
-                    list.add(new AxisAlignedBB(minX, minY, minZ, maxX, maxY, maxZ, false));
+                    AxisAlignedBB box = new AxisAlignedBB(minX, minY, minZ, maxX, maxY, maxZ, false);
+                    if (!box.isEmpty()) {
+                        list.add(box);
+                        ret = true;
+                    }
                 }
             }
+
+            return ret;
         } else {
+            boolean ret = false;
+
             java.util.List<AxisAlignedBB> boxes = shape.getBoundingBoxesRepresentation();
             for (int i = 0, len = boxes.size(); i < len; ++i) {
                 AxisAlignedBB box = boxes.get(i);
-                if (box.voxelShapeIntersect(aabb)) {
+                if (!box.isEmpty() && box.voxelShapeIntersect(aabb)) {
                     list.add(box);
+                    ret = true;
                 }
             }
+
+            return ret;
         }
     }
 
     public static void addBoxesTo(VoxelShape shape, java.util.List<AxisAlignedBB> list) {
         if (shape instanceof com.tuinity.tuinity.voxel.AABBVoxelShape) {
             com.tuinity.tuinity.voxel.AABBVoxelShape shapeCasted = (com.tuinity.tuinity.voxel.AABBVoxelShape)shape;
-            list.add(shapeCasted.aabb);
+            if (!shapeCasted.isEmpty()) {
+                list.add(shapeCasted.aabb);
+            }
         } else if (shape instanceof VoxelShapeArray) {
             VoxelShapeArray shapeCasted = (VoxelShapeArray)shape;
 
             for (AxisAlignedBB boundingBox : shapeCasted.boundingBoxesRepresentation) {
-                list.add(boundingBox.offset(shapeCasted.offsetX, shapeCasted.offsetY, shapeCasted.offsetZ));
+                if (!boundingBox.isEmpty()) {
+                    list.add(boundingBox.offset(shapeCasted.offsetX, shapeCasted.offsetY, shapeCasted.offsetZ));
+                }
             }
         } else {
             java.util.List<AxisAlignedBB> boxes = shape.getBoundingBoxesRepresentation();
             for (int i = 0, len = boxes.size(); i < len; ++i) {
                 AxisAlignedBB box = boxes.get(i);
-                list.add(box);
+                if (!box.isEmpty()) {
+                    list.add(box);
+                }
             }
         }
     }
@@ -392,6 +413,49 @@ public final class VoxelShapes {
 
     public static boolean combinationOccludes(VoxelShape voxelshape, VoxelShape voxelshape1) { return b(voxelshape, voxelshape1); } // Tuinity - OBFHELPER
     public static boolean b(VoxelShape voxelshape, VoxelShape voxelshape1) {
+        if (voxelshape == getFullUnoptimisedCube() || voxelshape == optimisedFullCube
+                || voxelshape1 == getFullUnoptimisedCube() || voxelshape1 == optimisedFullCube) {
+            return true;
+        }
+        boolean v1Empty = voxelshape == getEmptyShape();
+        boolean v2Empty = voxelshape1 == getEmptyShape();
+        if (v1Empty && v2Empty) {
+            return false;
+        }
+        if ((voxelshape instanceof com.tuinity.tuinity.voxel.AABBVoxelShape || v1Empty) && (voxelshape1 instanceof com.tuinity.tuinity.voxel.AABBVoxelShape || v2Empty)) {
+            if (!v1Empty && !v2Empty && (voxelshape != voxelshape1)) {
+                AxisAlignedBB boundingBox1 = ((com.tuinity.tuinity.voxel.AABBVoxelShape)voxelshape).aabb;
+                AxisAlignedBB boundingBox2 = ((com.tuinity.tuinity.voxel.AABBVoxelShape)voxelshape1).aabb;
+                // can call it here in some cases
+
+                // check overall bounding box
+                double minY = Math.min(boundingBox1.minY, boundingBox2.minY);
+                double maxY = Math.max(boundingBox1.maxY, boundingBox2.maxY);
+                if (minY > MCUtil.COLLISION_EPSILON || maxY < (1 - MCUtil.COLLISION_EPSILON)) {
+                    return false;
+                }
+                double minX = Math.min(boundingBox1.minX, boundingBox2.minX);
+                double maxX = Math.max(boundingBox1.maxX, boundingBox2.maxX);
+                if (minX > MCUtil.COLLISION_EPSILON || maxX < (1 - MCUtil.COLLISION_EPSILON)) {
+                    return false;
+                }
+                double minZ = Math.min(boundingBox1.minZ, boundingBox2.minZ);
+                double maxZ = Math.max(boundingBox1.maxZ, boundingBox2.maxZ);
+                if (minZ > MCUtil.COLLISION_EPSILON || maxZ < (1 - MCUtil.COLLISION_EPSILON)) {
+                    return false;
+                }
+                // fall through to full merge check
+            } else {
+                AxisAlignedBB boundingBox = v1Empty ? ((com.tuinity.tuinity.voxel.AABBVoxelShape)voxelshape1).aabb : ((com.tuinity.tuinity.voxel.AABBVoxelShape)voxelshape).aabb;
+                // check if the bounding box encloses the full cube
+                return (boundingBox.minY <= MCUtil.COLLISION_EPSILON && boundingBox.maxY >= (1 - MCUtil.COLLISION_EPSILON)) &&
+                       (boundingBox.minX <= MCUtil.COLLISION_EPSILON && boundingBox.maxX >= (1 - MCUtil.COLLISION_EPSILON)) &&
+                       (boundingBox.minZ <= MCUtil.COLLISION_EPSILON && boundingBox.maxZ >= (1 - MCUtil.COLLISION_EPSILON));
+            }
+        }
+        return b_rare(voxelshape, voxelshape1);
+    }
+    public static boolean b_rare(VoxelShape voxelshape, VoxelShape voxelshape1) {
         return (voxelshape != b() || voxelshape != getFullUnoptimisedCube()) && (voxelshape1 != b() || voxelshape1 != getFullUnoptimisedCube()) ? ((voxelshape == VoxelShapes.getEmptyShape() || voxelshape.isEmpty()) && (voxelshape1 == VoxelShapes.getEmptyShape() || voxelshape1.isEmpty()) ? false : !c(b(), b(voxelshape, voxelshape1, OperatorBoolean.OR), OperatorBoolean.ONLY_FIRST)) : true; // Tuinity - optimise call by checking against more constant shapes
     }
 
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 274a383be124c1abd42af07b359306c912ac5c50..d66c3e0b784b0b758b1aa79a963f4cacd5cbe10a 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -365,248 +365,15 @@ public class WorldServer extends World implements GeneratorAccessSeed {
     }
 
     // Tuinity start - optimise collision
-    public boolean collidesWithAnyBlockOrWorldBorder(@Nullable Entity entity, AxisAlignedBB axisalignedbb, boolean loadChunks) {
-        if (entity != null) {
-            if (this.getWorldBorder().isCollidingOnBorderEdge(axisalignedbb)) {
-                return true;
-            }
-        }
-
-        int minBlockX = MathHelper.floor(axisalignedbb.minX - MCUtil.COLLISION_EPSILON) - 1;
-        int maxBlockX = MathHelper.floor(axisalignedbb.maxX + MCUtil.COLLISION_EPSILON) + 1;
-
-        int minBlockY = MathHelper.floor(axisalignedbb.minY - MCUtil.COLLISION_EPSILON) - 1;
-        int maxBlockY = MathHelper.floor(axisalignedbb.maxY + MCUtil.COLLISION_EPSILON) + 1;
-
-        int minBlockZ = MathHelper.floor(axisalignedbb.minZ - MCUtil.COLLISION_EPSILON) - 1;
-        int maxBlockZ = MathHelper.floor(axisalignedbb.maxZ + MCUtil.COLLISION_EPSILON) + 1;
-
-
-        BlockPosition.MutableBlockPosition mutablePos = new BlockPosition.MutableBlockPosition();
-        VoxelShapeCollision collisionShape = entity == null ? VoxelShapeCollision.a() : VoxelShapeCollision.a(entity); // TODO make this lazy
-
-        // special cases:
-        if (minBlockY > 255 || maxBlockY < 0) {
-            // no point in checking
-            return false;
-        }
-
-        int minYIterate = Math.max(0, minBlockY);
-        int maxYIterate = Math.min(255, maxBlockY);
-
-        int minChunkX = minBlockX >> 4;
-        int maxChunkX = maxBlockX >> 4;
-
-        int minChunkZ = minBlockZ >> 4;
-        int maxChunkZ = maxBlockZ >> 4;
-
-        ChunkProviderServer chunkProvider = (ChunkProviderServer)this.chunkProvider;
-        // TODO special case single chunk?
-
-        for (int currChunkZ = minChunkZ; currChunkZ <= maxChunkZ; ++currChunkZ) {
-            int minZ = currChunkZ == minChunkZ ? minBlockZ & 15 : 0; // coordinate in chunk
-            int maxZ = currChunkZ == maxChunkZ ? maxBlockZ & 15 : 15; // coordinate in chunk
-
-            for (int currChunkX = minChunkX; currChunkX <= maxChunkX; ++currChunkX) {
-                int minX = currChunkX == minChunkX ? minBlockX & 15 : 0; // coordinate in chunk
-                int maxX = currChunkX == maxChunkX ? maxBlockX & 15 : 15; // coordinate in chunk
-
-                int chunkXGlobalPos = currChunkX << 4;
-                int chunkZGlobalPos = currChunkZ << 4;
-                Chunk chunk = loadChunks ? chunkProvider.getChunkAt(currChunkX, currChunkZ, true) : chunkProvider.getChunkAtIfLoadedImmediately(currChunkX, currChunkZ);
-
-                if (chunk == null) {
-                    return true;
-                }
-
-                ChunkSection[] sections = chunk.getSections();
-
-                // bound y
-
-                for (int currY = minYIterate; currY <= maxYIterate; ++currY) {
-                    ChunkSection section = sections[currY >>> 4];
-                    if (section == null || section.isFullOfAir()) {
-                        // empty
-                        // skip to next section
-                        currY = (currY & ~(15)) + 15; // increment by 15: iterator loop increments by the extra one
-                        continue;
-                    }
-
-                    DataPaletteBlock<IBlockData> blocks = section.blockIds;
-                    int blockKeyY = (currY & 15) << 8;
-
-                    int edgeCountY = (currY == minBlockY || currY == maxBlockY) ? 1 : 0;
-
-                    for (int currZ = minZ; currZ <= maxZ; ++currZ) {
-                        int blockKeyZY = blockKeyY | (currZ << 4);
-                        int blockZ = currZ | chunkZGlobalPos; // world position
-
-                        int edgeCountZY;
-                        if (blockZ == minBlockZ || blockZ == maxBlockZ) {
-                            edgeCountZY = edgeCountY + 1;
-                        } else {
-                            edgeCountZY = edgeCountY;
-                        }
-
-                        for (int currX = minX; currX <= maxX; ++currX) {
-                            int blockX = currX | chunkXGlobalPos; // world position
-
-                            int edgeCountFull;
-                            if (blockX == minBlockX || blockX == maxBlockX) {
-                                edgeCountFull = edgeCountZY + 1;
-                            } else {
-                                edgeCountFull = edgeCountZY;
-                            }
-
-                            if (edgeCountFull == 3) {
-                                continue;
-                            }
-
-                            int blockKeyFull = blockKeyZY | currX;
-                            IBlockData blockData = blocks.rawGet(blockKeyFull);
-
-                            if (!blockData.isAir() && (edgeCountFull != 1 || blockData.shapeExceedsCube()) && (edgeCountFull != 2 || blockData.getBlock() == Blocks.MOVING_PISTON)) {
-                                mutablePos.setValues(blockX, currY, blockZ);
-                                VoxelShape voxelshape2 = blockData.getCollisionShape(this, mutablePos, collisionShape);
-                                if (voxelshape2 != VoxelShapes.getEmptyShape()) {
-                                    VoxelShape voxelshape3 = voxelshape2.offset((double)blockX, (double)currY, (double)blockZ);
-
-                                    if (voxelshape3.intersects(axisalignedbb)) {
-                                        return true;
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-        return false;
+    public boolean collidesWithAnyBlockOrWorldBorder(@Nullable Entity entity, AxisAlignedBB axisalignedbb, boolean loadChunks,
+                                                     boolean collidesWithUnloaded) {
+        return this.getCollisionsForBlocksOrWorldBorder(entity, axisalignedbb, null, loadChunks, collidesWithUnloaded, true, null);
     }
 
-    public boolean collidesWithAnyBlockOrWorldBorder(@Nullable Entity entity, AxisAlignedBB axisalignedbb, boolean loadChunks, boolean collideWithUnloaded, java.util.function.BiPredicate<IBlockData, BlockPosition> predicate) {
-        if (entity != null) {
-            if (this.getWorldBorder().isCollidingOnBorderEdge(axisalignedbb)) {
-                return true;
-            }
-        }
-
-        int minBlockX = MathHelper.floor(axisalignedbb.minX - MCUtil.COLLISION_EPSILON) - 1;
-        int maxBlockX = MathHelper.floor(axisalignedbb.maxX + MCUtil.COLLISION_EPSILON) + 1;
-
-        int minBlockY = MathHelper.floor(axisalignedbb.minY - MCUtil.COLLISION_EPSILON) - 1;
-        int maxBlockY = MathHelper.floor(axisalignedbb.maxY + MCUtil.COLLISION_EPSILON) + 1;
-
-        int minBlockZ = MathHelper.floor(axisalignedbb.minZ - MCUtil.COLLISION_EPSILON) - 1;
-        int maxBlockZ = MathHelper.floor(axisalignedbb.maxZ + MCUtil.COLLISION_EPSILON) + 1;
-
-
-        BlockPosition.MutableBlockPosition mutablePos = new BlockPosition.MutableBlockPosition();
-        VoxelShapeCollision collisionShape = entity == null ? VoxelShapeCollision.a() : VoxelShapeCollision.a(entity); // TODO make this lazy
-
-        // special cases:
-        if (minBlockY > 255 || maxBlockY < 0) {
-            // no point in checking
-            return false;
-        }
-
-        int minYIterate = Math.max(0, minBlockY);
-        int maxYIterate = Math.min(255, maxBlockY);
-
-        int minChunkX = minBlockX >> 4;
-        int maxChunkX = maxBlockX >> 4;
-
-        int minChunkZ = minBlockZ >> 4;
-        int maxChunkZ = maxBlockZ >> 4;
-
-        ChunkProviderServer chunkProvider = (ChunkProviderServer)this.chunkProvider;
-        // TODO special case single chunk?
-
-        for (int currChunkZ = minChunkZ; currChunkZ <= maxChunkZ; ++currChunkZ) {
-            int minZ = currChunkZ == minChunkZ ? minBlockZ & 15 : 0; // coordinate in chunk
-            int maxZ = currChunkZ == maxChunkZ ? maxBlockZ & 15 : 15; // coordinate in chunk
-
-            for (int currChunkX = minChunkX; currChunkX <= maxChunkX; ++currChunkX) {
-                int minX = currChunkX == minChunkX ? minBlockX & 15 : 0; // coordinate in chunk
-                int maxX = currChunkX == maxChunkX ? maxBlockX & 15 : 15; // coordinate in chunk
-
-                int chunkXGlobalPos = currChunkX << 4;
-                int chunkZGlobalPos = currChunkZ << 4;
-                Chunk chunk = loadChunks ? chunkProvider.getChunkAt(currChunkX, currChunkZ, true) : chunkProvider.getChunkAtIfLoadedImmediately(currChunkX, currChunkZ);
-
-                if (chunk == null) {
-                    if (collideWithUnloaded) {
-                        return true;
-                    } else {
-                        continue;
-                    }
-                }
-
-                ChunkSection[] sections = chunk.getSections();
-
-                // bound y
-
-                for (int currY = minYIterate; currY <= maxYIterate; ++currY) {
-                    ChunkSection section = sections[currY >>> 4];
-                    if (section == null || section.isFullOfAir()) {
-                        // empty
-                        // skip to next section
-                        currY = (currY & ~(15)) + 15; // increment by 15: iterator loop increments by the extra one
-                        continue;
-                    }
-
-                    DataPaletteBlock<IBlockData> blocks = section.blockIds;
-                    int blockKeyY = (currY & 15) << 8;
-
-                    int edgeCountY = (currY == minBlockY || currY == maxBlockY) ? 1 : 0;
-
-                    for (int currZ = minZ; currZ <= maxZ; ++currZ) {
-                        int blockKeyZY = blockKeyY | (currZ << 4);
-                        int blockZ = currZ | chunkZGlobalPos; // world position
-
-                        int edgeCountZY;
-                        if (blockZ == minBlockZ || blockZ == maxBlockZ) {
-                            edgeCountZY = edgeCountY + 1;
-                        } else {
-                            edgeCountZY = edgeCountY;
-                        }
-
-                        for (int currX = minX; currX <= maxX; ++currX) {
-                            int blockX = currX | chunkXGlobalPos; // world position
-
-                            int edgeCountFull;
-                            if (blockX == minBlockX || blockX == maxBlockX) {
-                                edgeCountFull = edgeCountZY + 1;
-                            } else {
-                                edgeCountFull = edgeCountZY;
-                            }
-
-                            if (edgeCountFull == 3) {
-                                continue;
-                            }
-
-                            int blockKeyFull = blockKeyZY | currX;
-                            IBlockData blockData = blocks.rawGet(blockKeyFull);
-
-                            if (!blockData.isAir() && (edgeCountFull != 1 || blockData.shapeExceedsCube()) && (edgeCountFull != 2 || blockData.getBlock() == Blocks.MOVING_PISTON)) {
-                                mutablePos.setValues(blockX, currY, blockZ);
-                                VoxelShape voxelshape2 = blockData.getCollisionShape(this, mutablePos, collisionShape);
-                                if (voxelshape2 != VoxelShapes.getEmptyShape()) {
-                                    VoxelShape voxelshape3 = voxelshape2.offset((double)blockX, (double)currY, (double)blockZ);
-
-                                    if (voxelshape3.intersects(axisalignedbb) && (predicate == null || predicate.test(blockData, mutablePos))) {
-                                        return true;
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-        return false;
+    public boolean collidesWithAnyBlockOrWorldBorder(@Nullable Entity entity, AxisAlignedBB axisalignedbb,
+                                                     boolean loadChunks, boolean collidesWithUnloaded,
+                                                     java.util.function.BiPredicate<IBlockData, BlockPosition> predicate) {
+        return this.getCollisionsForBlocksOrWorldBorder(entity, axisalignedbb, null, loadChunks, collidesWithUnloaded, true, predicate);
     }
 
     public final boolean hardCollidesWithAnyEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Predicate<Entity> predicate) {
@@ -641,13 +408,24 @@ public class WorldServer extends World implements GeneratorAccessSeed {
     }
 
     public final boolean hasAnyCollisions(@Nullable Entity entity, AxisAlignedBB axisalignedbb, boolean loadChunks) {
-        return this.collidesWithAnyBlockOrWorldBorder(entity, axisalignedbb, loadChunks) || this.hardCollidesWithAnyEntities(entity, axisalignedbb, null);
+        return this.collidesWithAnyBlockOrWorldBorder(entity, axisalignedbb, loadChunks, true)
+                || this.hardCollidesWithAnyEntities(entity, axisalignedbb, null);
     }
 
-    public void getCollisionsForBlocksOrWorldBorder(@Nullable Entity entity, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, boolean loadChunks) {
+    // returns whether any collisions were detected
+    public boolean getCollisionsForBlocksOrWorldBorder(@Nullable Entity entity, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list,
+                                                    boolean loadChunks, boolean collidesWithUnloaded, boolean checkOnly,
+                                                    java.util.function.BiPredicate<IBlockData, BlockPosition> predicate) {
+        boolean ret = false;
+
         if (entity != null) {
             if (this.getWorldBorder().isCollidingOnBorderEdge(axisalignedbb)) {
-                VoxelShapes.addBoxesTo(this.getWorldBorder().getCollisionShape(), list);
+                if (checkOnly) {
+                    return true;
+                } else {
+                    VoxelShapes.addBoxesTo(this.getWorldBorder().getCollisionShape(), list);
+                    ret = true;
+                }
             }
         }
 
@@ -662,12 +440,12 @@ public class WorldServer extends World implements GeneratorAccessSeed {
 
 
         BlockPosition.MutableBlockPosition mutablePos = new BlockPosition.MutableBlockPosition();
-        VoxelShapeCollision collisionShape = entity == null ? VoxelShapeCollision.a() : VoxelShapeCollision.a(entity); // TODO make this lazy
+        VoxelShapeCollision collisionShape = null;
 
         // special cases:
         if (minBlockY > 255 || maxBlockY < 0) {
             // no point in checking
-            return;
+            return ret;
         }
 
         int minYIterate = Math.max(0, minBlockY);
@@ -695,7 +473,14 @@ public class WorldServer extends World implements GeneratorAccessSeed {
                 Chunk chunk = loadChunks ? chunkProvider.getChunkAt(currChunkX, currChunkZ, true) : chunkProvider.getChunkAtIfLoadedImmediately(currChunkX, currChunkZ);
 
                 if (chunk == null) {
-                    list.add(AxisAlignedBB.getBoxForChunk(currChunkX, currChunkZ));
+                    if (collidesWithUnloaded) {
+                        if (checkOnly) {
+                            return true;
+                        } else {
+                            list.add(AxisAlignedBB.getBoxForChunk(currChunkX, currChunkZ));
+                            ret = true;
+                        }
+                    }
                     continue;
                 }
 
@@ -712,46 +497,104 @@ public class WorldServer extends World implements GeneratorAccessSeed {
                         continue;
                     }
 
-                    DataPaletteBlock<IBlockData> blocks = section.blockIds;
-                    int blockKeyY = (currY & 15) << 8;
-
-                    int edgeCountY = (currY == minBlockY || currY == maxBlockY) ? 1 : 0;
-
-                    for (int currZ = minZ; currZ <= maxZ; ++currZ) {
-                        int blockKeyZY = blockKeyY | (currZ << 4);
-                        int blockZ = currZ | chunkZGlobalPos; // world position
+                    int minXIterate;
+                    int maxXIterate;
+                    int minZIterate;
+                    int maxZIterate;
 
-                        int edgeCountZY;
-                        if (blockZ == minBlockZ || blockZ == maxBlockZ) {
-                            edgeCountZY = edgeCountY + 1;
-                        } else {
-                            edgeCountZY = edgeCountY;
-                        }
-
-                        for (int currX = minX; currX <= maxX; ++currX) {
-                            int blockX = currX | chunkXGlobalPos; // world position
-
-                            int edgeCountFull;
-                            if (blockX == minBlockX || blockX == maxBlockX) {
-                                edgeCountFull = edgeCountZY + 1;
-                            } else {
-                                edgeCountFull = edgeCountZY;
-                            }
+                    boolean sectionHasSpecial = section.hasSpecialCollidingBlocks();
+                    if (sectionHasSpecial && currChunkX == minChunkX) {
+                        minXIterate = minX + 1;
+                    } else {
+                        minXIterate = minX;
+                    }
+                    if (sectionHasSpecial && currChunkX == maxChunkX) {
+                        maxXIterate = maxX - 1;
+                    } else {
+                        maxXIterate = maxX;
+                    }
 
-                            if (edgeCountFull == 3) {
-                                continue;
-                            }
+                    if (sectionHasSpecial && currChunkZ == minChunkZ) {
+                        minZIterate = minZ + 1;
+                    } else {
+                        minZIterate = minZ;
+                    }
+                    if (sectionHasSpecial && currChunkZ == maxChunkZ) {
+                        maxZIterate = maxZ - 1;
+                    } else {
+                        maxZIterate = maxZ;
+                    }
 
-                            int blockKeyFull = blockKeyZY | currX;
-                            IBlockData blockData = blocks.rawGet(blockKeyFull);
+                    DataPaletteBlock<IBlockData> blocks = section.blockIds;
 
-                            if (!blockData.isAir() && (edgeCountFull != 1 || blockData.shapeExceedsCube()) && (edgeCountFull != 2 || blockData.getBlock() == Blocks.MOVING_PISTON)) {
-                                mutablePos.setValues(blockX, currY, blockZ);
-                                VoxelShape voxelshape2 = blockData.getCollisionShape(this, mutablePos, collisionShape);
-                                if (voxelshape2 != VoxelShapes.getEmptyShape()) {
-                                    VoxelShape voxelshape3 = voxelshape2.offset((double)blockX, (double)currY, (double)blockZ);
+                    for (int currZ = minZIterate; currZ <= maxZIterate; ++currZ) {
+                        block_search_loop:
+                        for (int currX = minXIterate; currX <= maxXIterate; ++currX) {
+                            int localBlockIndex = (currX) | (currZ << 4) | ((currY & 15) << 8);
+                            long blockInfo = section.getKnownBlockInfo(localBlockIndex);
+                            switch ((int)blockInfo) {
+                                case (int)ChunkSection.KNOWN_EMPTY_BLOCK: {
+                                    continue block_search_loop;
+                                }
+                                case (int)ChunkSection.KNOWN_FULL_BLOCK: {
+                                    AxisAlignedBB box = new AxisAlignedBB(
+                                            currX | chunkXGlobalPos, currY, currZ | chunkZGlobalPos,
+                                            (currX | chunkXGlobalPos) + 1, currY + 1, (currZ | chunkZGlobalPos) + 1,
+                                            false
+                                    );
+                                    if (predicate != null) {
+                                        if (!box.voxelShapeIntersect(axisalignedbb)) {
+                                            continue block_search_loop;
+                                        }
+                                        // fall through to get the block for the predicate
+                                    } else {
+                                        if (box.voxelShapeIntersect(axisalignedbb)) {
+                                            if (checkOnly) {
+                                                return true;
+                                            } else {
+                                                list.add(box);
+                                                ret = true;
+                                            }
+                                        }
+                                        continue block_search_loop;
+                                    }
+                                }
+                                default: {
+                                    int blockX = currX | chunkXGlobalPos;
+                                    int blockY = currY;
+                                    int blockZ = currZ | chunkZGlobalPos;
+
+                                    int edgeCount = ((blockX == minBlockX || blockX == maxBlockX) ? 1 : 0) +
+                                            ((blockY == minBlockY || blockY == maxBlockY) ? 1 : 0) +
+                                            ((blockZ == minBlockZ || blockZ == maxBlockZ) ? 1 : 0);
+                                    if (edgeCount == 3 || (edgeCount != 0 && blockInfo != ChunkSection.KNOWN_SPECIAL_BLOCK)) {
+                                        continue block_search_loop;
+                                    }
 
-                                    VoxelShapes.addBoxesToIfIntersects(voxelshape3, axisalignedbb, list);
+                                    IBlockData blockData = blocks.rawGet(localBlockIndex);
+
+                                    if ((edgeCount != 1 || blockData.shapeExceedsCube()) && (edgeCount != 2 || blockData.getBlock() == Blocks.MOVING_PISTON)) {
+                                        mutablePos.setValues(blockX, blockY, blockZ);
+                                        if (collisionShape == null) {
+                                            collisionShape = entity == null ? VoxelShapeCollision.a() : VoxelShapeCollision.a(entity);
+                                        }
+                                        VoxelShape voxelshape2 = blockData.getCollisionShape(this, mutablePos, collisionShape);
+                                        if (voxelshape2 != VoxelShapes.getEmptyShape()) {
+                                            VoxelShape voxelshape3 = voxelshape2.offset((double)blockX, (double)blockY, (double)blockZ);
+
+                                            if (predicate != null && !predicate.test(blockData, mutablePos)) {
+                                                continue block_search_loop;
+                                            }
+
+                                            if (checkOnly) {
+                                                if (voxelshape3.intersects(axisalignedbb)) {
+                                                    return true;
+                                                }
+                                            } else {
+                                                ret |= VoxelShapes.addBoxesToIfIntersects(voxelshape3, axisalignedbb, list);
+                                            }
+                                        }
+                                    }
                                 }
                             }
                         }
@@ -759,6 +602,8 @@ public class WorldServer extends World implements GeneratorAccessSeed {
                 }
             }
         }
+
+        return ret;
     }
 
     public final void getEntityHardCollisions(@Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Predicate<Entity> predicate, List<AxisAlignedBB> list) {
@@ -778,7 +623,9 @@ public class WorldServer extends World implements GeneratorAccessSeed {
                 Entity otherEntity = entities.get(i);
 
                 if ((entity == null || otherEntity.collisionBoxIsHard()) || entity.hardCollidesWith(otherEntity)) {
-                    list.add(otherEntity.getBoundingBox());
+                    if (!otherEntity.getBoundingBox().isEmpty()) {
+                        list.add(otherEntity.getBoundingBox());
+                    }
                 }
             }
         } finally {
@@ -787,10 +634,15 @@ public class WorldServer extends World implements GeneratorAccessSeed {
     }
 
     public final void getCollisions(@Nullable Entity entity, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, boolean loadChunks) {
-        this.getCollisionsForBlocksOrWorldBorder(entity, axisalignedbb, list, loadChunks);
+        this.getCollisionsForBlocksOrWorldBorder(entity, axisalignedbb, list, loadChunks, true, false, null);
         this.getEntityHardCollisions(entity, axisalignedbb, null, list);
     }
 
+    @Override
+    public boolean getCubes(AxisAlignedBB axisalignedbb) {
+        return !this.hasAnyCollisions(null, axisalignedbb);
+    }
+
     @Override
     public boolean getCubes(Entity entity) {
         return !this.hasAnyCollisions(entity, entity.getBoundingBox());
@@ -805,7 +657,7 @@ public class WorldServer extends World implements GeneratorAccessSeed {
     @Override
     public boolean getCubes(@Nullable Entity entity, AxisAlignedBB axisalignedbb, Predicate<Entity> predicate) {
         if (entity instanceof EntityArmorStand && !entity.world.paperConfig.armorStandEntityLookups) return false;
-        return !this.collidesWithAnyBlockOrWorldBorder(entity, axisalignedbb, true) && !this.hardCollidesWithAnyEntities(entity, axisalignedbb, predicate);
+        return !this.collidesWithAnyBlockOrWorldBorder(entity, axisalignedbb, true, true) && !this.hardCollidesWithAnyEntities(entity, axisalignedbb, predicate);
     }
     // Tuinity end - optimise collision
 
